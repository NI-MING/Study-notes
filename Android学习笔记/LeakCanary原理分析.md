# LeakCanary原理分析

LeakCanary是用来检测我们的App在运行中是否发生了内存泄漏，不是所有的类它都可以检测到，它只能检测到我们的Activity和Fragment的内存泄漏。

LeakCanary判断内存泄漏的方法非常的科学和巧妙，如果让我来实现这个功能，我想不到使用引用来监测。可能会使用finalize方法。之后了解到，Java中不推荐使用finalize方法，因为该方法不确定性太大，也就是说JVM不会保证一定调用这个方法。同时如果这个方法里有一些耗时的操作可能导致F-QUEUE队列中的其他对象处于等待回收的状态，阻塞了其回收，甚至引起内存回收子系统的崩溃。JVM建议我们判断对象是否被回收使用引用队列来实现。

LeakCanary只可以检查我们的Activity和Fragment的内存泄漏，当我们添加完依赖之后，LeakCanary已经可以工作了，老版本需要调用install方法，install方法中，添加了对Activity和Fragment的监听，分别是ActivityDestroyWatcher和FragmentDestroyWatcher。

在这两个类中，会调用监听组件生命周期的回调函数ActivityLifecycleCallbacks，重写了其中的onActivityDestroyed，也就是说，当我们的生命周期走到onDestroy中时，会调用该重写方法，在其中来监听我们的对象有没有被垃圾回收。

这时就来到我们ObjectWatcher.watch方法中了，在这个方法中，会先创建一个检测没有回收对象的队列，然后将我们组件和一个生成的key包装进一个弱引用对象，放在这个队列中，之后就会去检测我们的引用队列中是否有弱引用，如果有，就将该引用包裹的Activity从我们的检测没有回收对象的队列中移除，之后如果队列不为空，就进行一次GC，再移除一次，如果这次队列不为空，就说明发生了内存泄漏，就会分析堆内存，导出文件。

