# OkHttp原理分析

### 具体流程

OkHttp内部是通过责任链模式完成，将网络请求的各个阶段封装到各个拦截器中，实现了各层之间的解耦。

发起请求的核心代码逻辑是通过OkHttpClient的newCall方法创建一个Call对象，这个Call对象的唯一实现类是RealCall，并调用了Call的execute方法，如果是异步的话，就调用enqueue方法。

之后会将Call委托给 Dispatcher 这个类进行管理调度，这个类中设置了最大并发请求数（64）和并发请求主机数（5），同时还维护三个队列：同步请求队列，准备异步请求队列和正在异步请求队列；同时还创建了一个线程池，这个线程池类似于CacheThreadPool，核心线程数0，最大线程数为Integer.MAX_VALUE。

在这两个方法中，会调用 Dispatcher 的 execute 方法或enqueue方法，execute方法直接将Call添加进同步请求队列，enqueue方法是将一个被AsyncCall包裹的Call添加到准备异步请求队列中，AsyncCall实现了Runnable接口，会作为线程池的参数使用。放入准备请求队列后，会立即调用promoteAndExecute方法，该方法遍历准备队列拿到asyncCall，判断最大并发请求数和主机数，满足条件后加入线程池执行并发请求，同时放入正在异步请求队列。

接下来主要就是看AsyncCall中的run方法是怎样实现的。

run方法里直接调用了getResponseWithInterceptorChain 方法，然后就做了回调。

至此，我们就要进入拦截链做真正的网络请求了。

getResponseWithInterceptorChain 方法中初始化了interceptors数组，该数组是存储所有的拦截器的。拦截器总共有七个，前一个拦截器必须调用一次proceed方法，才能将请求传递下去。下面将大概介绍各个拦截器的功能：

**应用拦截器（ApplicationInterceptor）**：拿到原始的请求，方便添加自定义请求头等。

**RetryAndFollowUpInterceptor**：该拦截器负责重定向请求和失败重试，重试最大次数为20次。

**BridgeInterceptor**：应用层和网络层的桥接拦截器，该拦截器负责为请求添加固定的请求头，比如：Host、Content-Length、Content-Type、User-Agent，和压缩解压缩。

**CacheInterceptor**：该拦截器主要负责通过URL哈希后的值获取缓存，并实现一系列缓存策略。

**ConnectInterceptor**：该拦截器主要负责从连接池中获取socket连接，负责连接复用，或者创建连接（三次握手）、释放连接以及创建流并用Okio包装。

**NetworkInterceptors**：用户自定义拦截器，通常用于监控网络层数据。

**CallServerInterceptor**：请求拦截器，在所有准备工作完成后，发起网络请求。（注意post的两次请求，100-continue）



接下来主要分析缓存拦截器的缓存策略和连接拦截器的连接复用

### OkHttp的缓存策略

想要搞清楚OkHttp的缓存策略，就先要了解HTTP的缓存机制

HTTP1.0时，是使用Expires头标识缓存有效期的，它是根据服务器生成一个绝对的时间，然后发给客户端缓存，客户端根据自己的本地时间来判断缓存是否有效。这种缓存最大的问题是依赖客户端本地时间，不能防止用户修改本地时间，就导致无法准确判断缓存是否有效。

因此在HTTP1.1开始使用Cache-Control头表示缓存状态，它的优先级高于Expires，常见的取值为下面的一个或多个：

* private，默认值，标识那些私有的业务逻辑数据，比如根据用户行为下发的推荐数据。该模式下网络链路中的代理服务器等节点不应该缓存这部分数据，因为没有实际意义。

* public 与private相反，public用于标识那些通用的业务数据，比如获取新闻列表，所有人看到的都是同一份数据，因此客户端、代理服务器都可以缓存。

* no-cache 可进行缓存，但在客户端使用缓存前必须要去服务端进行缓存资源有效性的验证，即下文的对比缓存部分，我们稍后介绍。

* max-age 表示缓存时长单位为秒，指一个时间段，比如一年，通常用于不经常变化的静态资源。

* no-store 任何节点禁止使用缓存。

**强制缓存**：在上述缓存头规约基础之上，强制缓存是指网络请求响应header标识了Expires或Cache-Control带了max-age信息，而此时客户端计算缓存并未过期，则可以直接使用本地缓存，而不用真正发起网络请求。

**协商缓存**：强制缓存最大的问题是，一旦服务器资源有更新，直至缓存时间截至之前，客户端无法获取到最新的资源（除非请求时添加no-store），另外大部分情况下服务器的资源无法直接确定缓存失效时间，所以使用对比缓存更加灵活。

使用Last-Modify / If-Modify-Since头实现协商缓存，具体方法是服务端响应头添加Last-Modify头标识资源最后修改的时间，单位为秒，当客户端再次发起请求时，携带If-Modify-Since，值为Last-Modify。

服务端判断最后修改时间是否一致，如果一致就返回304并且body为空，客户端使用本地缓存。

这个Last-Modify有一定的局限性：

* 它的单位是秒，因此无法对一秒之内的修改做出标识
* 资源修改时间不能作为资源是否被修改的唯一依据

因此，HTTP还提供了另一组头信息来处理缓存，ETag/If-None-Match。流程与Last-Modify一样，只是ETag是资源文件的唯一标识符，服务端资源变化一定会导致ETag变化。

了解了HTTP的缓存机制，接下来看一看OkHttp的缓存策略

1. 第一次拿到响应后根据头信息决定是否缓存。
2. 下次请求时判断是否存在本地缓存，是否需要使用对比缓存、封装请求头信息等等。
3. 如果缓存失效或者需要对比缓存则发出网络请求，否则使用本地缓存。

缓存策略的实现类是CacheStrategy，其中有两个参数：

* networkRequest
* cacheResponse

| networkRequest | cacheResponse | CacheStrategy                                                |
| -------------- | ------------- | ------------------------------------------------------------ |
| null           | null          | only-if-cached(表明不进行网络请求，且缓存不存在或者过期，一定会返回 503 错误) |
| null           | non-null      | 不进行网络请求，而且缓存可以使用，直接返回缓存，不用请求网络 |
| non-null       | null          | 需要进行网络请求，而且缓存不存在或者过期，直接访问网络。     |
| non-null       | not-null      | Header 中含有 ETag/Last-Modified 标识，需要在条件请求下使用，还是需要访问网络。 |

具体流程如下所示：

- 读取候选缓存。
- 根据候选缓存创建缓存策略。
- 根据缓存策略，如果不进行网络请求，而且没有缓存数据时，报错返回错误码 504。
- 根据缓存策略，如果不进行网络请求，缓存数据可用，则直接返回缓存数据。
- 缓存无效，则继续执行网络请求。
- 通过服务端校验后，缓存数据可以使用（返回 304），则直接返回缓存数据，并且更新缓存。
- 读取网络结果，构造 response，对数据进行缓存。

### OkHttp连接池

为什么需要连接池：

由于频繁的建立和断开Socket是非常消耗网络资源和浪费时间的，所以HTTP中的keepalive连接对于降低延迟和提升速度有非常重要的作用。

keepalive机制可以在一次TCP连接中持续发送多份数据而不会断开连接。所以连接可以多次使用。而复用连接就需要对连接进行管理，于是就有了连接池概念。

如何实现？

ConectionPool中维护一个双端队列用来存储连接，通过get方法获取连接。

OkHttp支持五个并发的keepalive，默认链路生命为5分钟（连接空闲后，保持）

OkHttp会优先从连接池中取出空闲连接，没有则就创建新的连接并将其放入连接池。